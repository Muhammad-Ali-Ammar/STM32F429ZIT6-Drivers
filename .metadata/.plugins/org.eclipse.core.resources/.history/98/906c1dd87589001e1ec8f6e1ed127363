/**************************************************************************/
/* Filename						: USART_private.h                                 */
/* Author  	    				: Muhammad Ammar                          */
/* Date 						: Nov 22, 2023  	           	 	         	 */ 
/* Version 	 					: V01                                     */
/* MicroController  			: STM32429 								   */
/**************************************************************************/


#ifndef UART_USART_PRIVATE_H_
#define UART_USART_PRIVATE_H_



/********************************** Includes *********************************************/



/********************************** Macros Declarations *******************************/



/********************************** Macros Function Declarations *********************/


#define Usart_SetBaudrateIntPart(_CHANNEL_,_VALUE_)                     ((uartArr[(_CHANNEL_)]->USART_BRR ) = ((uartArr[(_CHANNEL_)]->USART_BRR ) & 0xFFF0) | (((_VALUE_)<< FOUR_VALUE ) & 0xFFFF000F))
#define Usart_SetBaudrateFractionPart(_CHANNEL_,_VALUE_)                     ((uartArr[(_CHANNEL_)]->USART_BRR ) = ((uartArr[(_CHANNEL_)]->USART_BRR ) & 0xFFF0) | (((_VALUE_)<< FOUR_VALUE ) & 0xFFFF000F))


/********************************** Data Type Declarations ****************************/

extern u64 Global_u64ABP1Freq;
extern u64 Global_u64ABP2Freq;

typedef volatile struct{
  	u32 USART_SR;
  	u32 USART_DR;
  	u32 USART_BRR;
  	u32 USART_CR1;
  	u32 USART_CR2;
  	u32 USART_CR3;
  	u32 USART_GPTR;
  }USARTx_Type;


#define USART1 	((volatile USARTx_Type*)(0x40011000))
#define USART2 	((volatile USARTx_Type*)(0x40004400))
#define USART3 	((volatile USARTx_Type*)(0x40004800))
#define USART4 	((volatile USARTx_Type*)(0x40004C00))
#define USART5 	((volatile USARTx_Type*)(0x40005000))
#define USART6 	((volatile USARTx_Type*)(0x40011400))
#define USART7 	((volatile USARTx_Type*)(0x40007800))
#define USART8 	((volatile USARTx_Type*)(0x40007C00))



static volatile USARTx_Type* uartArr[] = {USART1,USART2,USART3,USART4,USART5,USART6,USART7,USART8};

/********************************** Software Interfaces Declarations *******************/
static Usart_StatusErrorType Usart_enuSetBaudrate(const Usart_ConfigType* Address_Usart){
	Usart_StatusErrorType Loc_UsartStatusError = USART_STATUS_OK;
	f64 Loc_f64Brr ;
	u64 Loc_u64Fraction ;
	u64 Loc_u64IntPart ;
	u8 Loc_u8OverRun;
	if(Address_Usart == NULL){
		Loc_UsartStatusError = USART_STATUS_NULL_POINTER_ADDRESS;
	}
	else{
		Loc_u8OverRun = Address_Usart->select_oversample & 0b10;

		switch(Address_Usart->select_channel_number){

		case USART_SELECT_CHANNEL_1:
		case USART_SELECT_CHANNEL_6:

			Loc_f64Brr = (f64)Global_u64ABP2Freq/(Address_Usart->baude_rate)/(8*(2-Loc_u8OverRun));
			Loc_u64IntPart = (u64)Loc_f64Brr;
			Loc_u64Fraction =(Loc_f64Brr-Loc_u64IntPart)*16+0.5;
			if(Loc_u64Fraction ==16){
				Loc_u64Fraction = 0;
				Loc_u64IntPart++;
			}
			Usart_SetBaudrateIntPart(Address_Usart->select_channel_number,Loc_u64IntPart);
			Usart_SetBaudrateFractionPart(Address_Usart->select_channel_number,Loc_u64IntPart);

			break;

		}
	}
	return Loc_UsartStatusError;

}


#endif /* UART_USART_PRIVATE_H_ */
